<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Walled Garden Debug Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .test-section {
            margin-bottom: 25px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #f9f9f9;
        }

        .test-section h2 {
            font-size: 16px;
            margin-bottom: 15px;
            color: #444;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
        }

        .status.pending {
            background: #ffc107;
            color: #000;
        }

        .status.success {
            background: #4caf50;
            color: white;
        }

        .status.error {
            background: #f44336;
            color: white;
        }

        .result {
            margin-top: 10px;
            padding: 12px;
            background: white;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .button:hover {
            background: #5568d3;
        }

        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 4px;
        }

        .info-box strong {
            color: #1976d2;
        }

        .params {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
        }

        .params div {
            margin-bottom: 5px;
            font-size: 13px;
        }

        .params strong {
            color: #666;
            display: inline-block;
            width: 100px;
        }

        .icon {
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Walled Garden Debug Tool</h1>
        <p class="subtitle">Test if your MikroTik walled garden is configured correctly</p>

        <div class="info-box">
            <strong>üìå Important:</strong> Run this tool BEFORE logging into the hotspot to test walled garden access.
        </div>

        <div class="params" id="paramsBox">
            <strong>MikroTik Parameters:</strong><br>
            <div id="paramsList">Loading...</div>
        </div>

        <div class="test-section">
            <h2>
                <span class="icon">üåê</span>
                Test 1: Frontend Connectivity
                <span class="status pending" id="status1">Testing...</span>
            </h2>
            <div class="result" id="result1">Checking if frontend can be reached...</div>
        </div>

        <div class="test-section">
            <h2>
                <span class="icon">üîå</span>
                Test 2: Backend API Connectivity
                <span class="status pending" id="status2">Testing...</span>
            </h2>
            <div class="result" id="result2">Checking if backend API can be reached...</div>
        </div>

        <div class="test-section">
            <h2>
                <span class="icon">üì¶</span>
                Test 3: Fetch Plans API
                <span class="status pending" id="status3">Testing...</span>
            </h2>
            <div class="result" id="result3">Attempting to fetch plans...</div>
        </div>

        <div class="test-section">
            <h2>
                <span class="icon">üîß</span>
                Test 4: DNS Resolution
                <span class="status pending" id="status4">Testing...</span>
            </h2>
            <div class="result" id="result4">Testing DNS resolution...</div>
        </div>

        <button class="button" onclick="runAllTests()">üîÑ Run Tests Again</button>
    </div>

    <script>
        const FRONTEND_URL = 'https://isp-frontend-two.vercel.app';
        const BACKEND_URL = 'https://isp.bitwavetechnologies.com';
        const API_ENDPOINT = 'https://isp.bitwavetechnologies.com/api/plans?user_id=1';

        // Extract MikroTik parameters
        function getMikroTikParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                mac: params.get('mac') || 'N/A',
                ip: params.get('ip') || 'N/A',
                gw: params.get('gw') || 'N/A',
                router: params.get('router') || 'N/A'
            };
        }

        // Display parameters
        function displayParams() {
            const params = getMikroTikParams();
            const html = `
                <div><strong>MAC:</strong> ${params.mac}</div>
                <div><strong>IP:</strong> ${params.ip}</div>
                <div><strong>Gateway:</strong> ${params.gw}</div>
                <div><strong>Router:</strong> ${params.router}</div>
            `;
            document.getElementById('paramsList').innerHTML = html;
        }

        // Update test status
        function updateTest(testNum, status, message) {
            const statusEl = document.getElementById(`status${testNum}`);
            const resultEl = document.getElementById(`result${testNum}`);
            
            statusEl.className = `status ${status}`;
            statusEl.textContent = status === 'success' ? '‚úì Passed' : status === 'error' ? '‚úó Failed' : '‚è≥ Testing...';
            resultEl.textContent = message;
        }

        // Test 1: Frontend connectivity
        async function testFrontend() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);

                const response = await fetch(FRONTEND_URL + '/', {
                    method: 'HEAD',
                    mode: 'no-cors',
                    signal: controller.signal
                });

                clearTimeout(timeout);
                updateTest(1, 'success', `‚úì Frontend is reachable\nURL: ${FRONTEND_URL}\nStatus: Connection successful`);
                return true;
            } catch (error) {
                updateTest(1, 'error', `‚úó Frontend unreachable\nURL: ${FRONTEND_URL}\nError: ${error.message}\n\n‚ö†Ô∏è Add to walled garden: ${FRONTEND_URL.replace('https://', '')}`);
                return false;
            }
        }

        // Test 2: Backend connectivity
        async function testBackend() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);

                const response = await fetch(BACKEND_URL + '/', {
                    method: 'HEAD',
                    mode: 'no-cors',
                    signal: controller.signal
                });

                clearTimeout(timeout);
                updateTest(2, 'success', `‚úì Backend is reachable\nURL: ${BACKEND_URL}\nStatus: Connection successful`);
                return true;
            } catch (error) {
                updateTest(2, 'error', `‚úó Backend unreachable\nURL: ${BACKEND_URL}\nError: ${error.message}\n\n‚ö†Ô∏è Add to walled garden: ${BACKEND_URL.replace('https://', '')}`);
                return false;
            }
        }

        // Test 3: Fetch Plans API
        async function testPlansAPI() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 15000);

                const response = await fetch(API_ENDPOINT, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors',
                    signal: controller.signal
                });

                clearTimeout(timeout);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                const plansCount = Array.isArray(data) ? data.length : 0;

                updateTest(3, 'success', `‚úì Plans API is working!\nURL: ${API_ENDPOINT}\nStatus: ${response.status} OK\nPlans found: ${plansCount}\n\nData: ${JSON.stringify(data, null, 2).substring(0, 200)}...`);
                return true;
            } catch (error) {
                let errorMsg = `‚úó Plans API failed\nURL: ${API_ENDPOINT}\nError: ${error.message}\n\n`;
                
                if (error.message.includes('fetch')) {
                    errorMsg += '‚ö†Ô∏è WALLED GARDEN ISSUE!\n';
                    errorMsg += '‚Üí Add to MikroTik walled garden:\n';
                    errorMsg += '   /ip hotspot walled-garden\n';
                    errorMsg += '   add dst-host=isp.bitwavetechnologies.com action=allow\n\n';
                    errorMsg += '‚Üí Or check CORS headers on backend';
                } else if (error.name === 'AbortError') {
                    errorMsg += '‚ö†Ô∏è TIMEOUT - Likely walled garden blocking request';
                }

                updateTest(3, 'error', errorMsg);
                return false;
            }
        }

        // Test 4: DNS Resolution
        async function testDNS() {
            try {
                const domains = [
                    'isp.bitwavetechnologies.com',
                    'isp-frontend-two.vercel.app'
                ];

                let results = 'DNS Resolution Test:\n\n';
                let allPassed = true;

                for (const domain of domains) {
                    try {
                        const startTime = Date.now();
                        await fetch(`https://${domain}/`, { method: 'HEAD', mode: 'no-cors' });
                        const endTime = Date.now();
                        results += `‚úì ${domain}\n  Response time: ${endTime - startTime}ms\n\n`;
                    } catch (error) {
                        allPassed = false;
                        results += `‚úó ${domain}\n  Error: ${error.message}\n\n`;
                    }
                }

                if (!allPassed) {
                    results += '\n‚ö†Ô∏è DNS Issues Detected!\n';
                    results += '‚Üí Allow DNS in walled garden:\n';
                    results += '   /ip hotspot walled-garden ip\n';
                    results += '   add action=accept dst-port=53 protocol=udp';
                }

                updateTest(4, allPassed ? 'success' : 'error', results);
                return allPassed;
            } catch (error) {
                updateTest(4, 'error', `‚úó DNS test failed\nError: ${error.message}`);
                return false;
            }
        }

        // Run all tests
        async function runAllTests() {
            console.log('üîç Starting diagnostic tests...');

            // Reset all tests
            for (let i = 1; i <= 4; i++) {
                updateTest(i, 'pending', 'Testing...');
            }

            // Run tests sequentially
            await testFrontend();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testBackend();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testPlansAPI();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testDNS();

            console.log('‚úÖ All tests completed');
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            displayParams();
            setTimeout(runAllTests, 1000);
        });
    </script>
</body>
</html>

